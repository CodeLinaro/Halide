namespace Halide.Serdes;

// This corresponds to the version.
file_identifier "HLD0";

// File extension of any written files.
file_extension "hir";

// from src/IR.cpp
union Stmt {
    LetStmt,
    AssertStmt,
    ProducerConsumer,
    For,
    Store,
    Provide,
    Allocate,
    Free,
    Realize,
    Block,
    IfThenElse,
    Evaluate,
    Prefetch,
    Acquire,
    Fork,
    Atomic,
}

// TODO: handle type?
union Expr {
    IntImm,
    UIntImm,
    FloatImm,
    StringImm,
    Cast,
    Reinterpret,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Min,
    Max,
    EQ,
    NE,
    LT,
    LE,
    GT,
    GE,
    And,
    Or,
    Not,
    Select,
    Load,
    Ramp,
    Broadcast,
    Let,
    Call,
    Variable,
    Shuffle,
    VectorReduce,
}

enum ForType: byte {
    Serial,
    Parallel,
    Vectorized,
    Unrolled,
    Extern,
    GPUBlock,
    GPUThread,
    GPULane,
}

enum DeviceAPI: byte {
    None,
    Host,
    Default_GPU,
    CUDA,
    OpenCL,
    OpenGLCompute,
    Metal,
    Hexagon,
    HexagonDma,
    D3D12Compute,
    Vulkan,
    WebGPU,
}

enum MemoryType: byte {
    Auto,
    Heap,
    Stack,
    Register,
    GPUShared,
    GPUTexture,
    LockedCache,
    VTCM,
    AMXTile,
}

table LetStmt {
    name: string;
    value: Expr;
    body: Stmt;
}

table AssertStmt {
    condition: Expr;
    message: Expr;
}

table ProducerConsumer {
    name: string;
    is_producer: bool;
    body: Stmt;
}

table For {
    name: string;
    min: Expr;
    extent: Expr;
    for_type: ForType;
    device_api: DeviceAPI;
    body: Stmt;
}

table Store {
    name: string;
    predicate: Expr;
    value: Expr;
    index: Expr;
    // param: Parameter; TODO: no Parameter yet
    // alignment: ModulusRemainder; TODO: no ModulusRemainder yet
}

table Provide {
    name: string;
    values: [Expr];
    args: [Expr];
    predicate: Expr;
}

table Allocate {
    name: string;
    type: Type;
    memory_type: MemoryType;
    extents: [Expr];
    condition: Expr;
    new_expr: Expr;
    free_function: string;
    padding: int32;
    body: Stmt;
}

table Free {
    name: string;
}

table Realize {
    name: string;
    types: [Type];
    memory_type: MemoryType;
    // bounds: Region; TODO: no Range yet
    condition: Expr;
    body: Stmt;
}

table Block {
    first: Stmt;
    rest: Stmt;
}

table IfThenElse {
    condition: Expr;
    then_case: Stmt;
    else_case: Stmt;
}

table Evaluate {
    value: Expr;
}

table Prefetch {
    name: string;
    types: [Type];
    // bounds: Region; TODO: no Region yet
    // prefetch: PrefetchDirective; TODO: no PrefetchDirective yet
    condition: Expr;
    body: Stmt;
}

table Acquire {
    semaphore: Expr;
    count: Expr;
    body: Stmt;
}

table Fork {
    first: Stmt;
    rest: Stmt;
}

table Atomic {
    producer_name: string;
    mutex_name: string;
    body: Stmt;
}

table IntImm {
    value: int64;
}

table UIntImm {
    value: uint64;
}

table FloatImm {
    value: float64;
}

table StringImm {
    value: string;
}

table Cast {
    value: Expr;
}

table Reinterpret {
    value: Expr;
}

table Add {
    a: Expr;
    b: Expr;
}

table Sub {
    a: Expr;
    b: Expr;
}

table Mul {
    a: Expr;
    b: Expr;
}

table Div {
    a: Expr;
    b: Expr;
}

table Mod {
    a: Expr;
    b: Expr;
}

table Min {
    a: Expr;
    b: Expr;
}

table Max {
    a: Expr;
    b: Expr;
}

table EQ {
    a: Expr;
    b: Expr;
}

table NE {
    a: Expr;
    b: Expr;
}

table LT {
    a: Expr;
    b: Expr;
}

table LE {
    a: Expr;
    b: Expr;
}

table GT {
    a: Expr;
    b: Expr;
}

table GE {
    a: Expr;
    b: Expr;
}

table And {
    a: Expr;
    b: Expr;
}

table Or {
    a: Expr;
    b: Expr;
}

table Not {
    a: Expr;
}

table Select {
    condition: Expr;
    true_value: Expr;
    false_value: Expr;
}

table Load {
    name: string;
    predicate: Expr;
    index: Expr;
    // image: Buffer;  TODO: no Buffer yet
    // param: Parameter; TODO: no Parameter yet
    // alignment: ModulusRemainder; TODO: no ModulusRemainder yet
}

table Ramp {
    base: Expr;
    stride: Expr;
    lanes: int32;
}

table Broadcast {
    value: Expr;
    lanes: int32;
}

table Let {
    name: string;
    value: Expr;
    body: Expr;
}

table Call {
    name: string;
    args: [Expr];
    // call_type: CallType;
    // func: FunctionPtr; TODO: no FunctionPtr yet
    value_index: int32;
    // image: Buffer; TODO: no Buffer yet
    // param: Parameter; TODO: no Parameter yet
}

table Variable {
    name: string;
    // param: Parameter; TODO: no Parameter yet
    // image: Buffer; TODO: no Buffer yet
    // reduction_domain: ReductionDomain; TODO: no ReductionDomain yet
}

table Shuffle {
    vectors: [Expr];
    indices: [int32];
}

// TODO: lanes is not stored
table VectorReduce {
    value: Expr;
    // reduction_op: VectorReduceOp;
}

enum TypeCode: byte {
    Int,
    UInt,
    Float,
    Handle,
    BFloat,
}

// TODO: no halide_handle_cplusplus_type yet
table Type {
    code: TypeCode;
    bits: uint8;
    lanes: int32;
}

// Halide::internal::Function
table Func {
    name: string;
    origin_name: string;
    output_types: [Type];
    required_types: [Type];
    required_dims: int32;
    args: [string];
    // func_schedule: FuncSchedule;
    // init_def: Definition;
    // updates: [Definition];
    // debug_file: string;
    // output_buffers: [Parameter];
    // extern_arguments: [ExternFuncArgument];
    // extern_function_name: string;
}

table Pipeline {
    outputs: [Func];
    requirements: [Stmt];
    // trace_pipeline: bool;
}

root_type Pipeline;
